---
title: 트랜스포트 계층(Transport Layer)(4)
date: 2023-07-24 00:00:00 +09:00
categories: [ Computer Science, Network ]
tags: [ Transport, TCP ]
math: true
---

# 연결지향형 트랜스포트: TCP

## 혼잡 제어에 대한 접근법

실제로 TCP가 혼잡 제어를 수행하는 두 가지 광범위한 접근 방식이 있습니다. 
가장 크게 보면 네트워크 계층이 혼잡 제어를 목적으로 트랜스포트 계층에 어떤 직접적인 도움을 제공하는지에 따라 혼잡 제어 접근을 구별할 수 있습니다. 

- 종단 간의 혼잡 제어: 혼잡 제어에 대한 종단 간의 접근 방식에서 네트웤 ㅡ계층은 혼잡 제어 목적을 위해 트랜스포트 계층에게 어떤 직접적인 지원도 제공하지 않습니다. 네트워크에서 혼잡의 존재는 단지 관찰된
  네트워크 동작에 기바초하여 종단 시스템이 추측해야합니다. IP 계층은 네트워크 혼잡에 관해 종단 시스템에게 어떠한 피드백 제공도 요구받지 않으므로 TCP가 혼잡 제어를 위한 종단 간의 접근 방식을 취합니다.
  TCP 세그먼트 손실은 네트워크 혼잡의 발생 표시로 간주하고 TCP는 그에 따라서 윈도 크기를 줄입니다. 또한 TCP에 대한 새로운 제안으로 증가하는 왕복 지연값을 네트워크 혼잡 증가 지표로 사용합니다. 
- 네트워크 지원 혼잡 제어: 네트워크 지원 혼잡 제어에서 라우터들은 네트워크 안에서 혼잡 상태와 관련하여 송신자나 수신자 또는 모두에게 직접적인 피드백을 제공합니다. 이 피드백은 링크의 혼잡을 나타내는 하나의
  비트처럼 간단하며 혼잡 제어에서 라우터는 자신이 출력 링크(outgoing link)에 제공할 수 있는 전송률을 송신자에게 명확히 알릴 수 있게 해줍니다. 인터넷 기본 버전의 IP 및 TCP는 혼잡 제어에 대해
  종단 간 접근 방식을 채택했으나 최근에 IP와 TCP가 네트워크 혼잡 제어를 선택적으로 구현할 수 있습니다.

## TCP 혼잡 제어

TCP가 취한 접근 방식은 네트워크 혼잡에 따라 연결에 트래픽을 보내는 전송률을 각 송신자가 제한하도록 하는 것입니다. 
만약 TCP 송신자가 자신과 목적지 간의 경로에서 혼잡이 없음을 감지하면 송신자는 송신율을 높입니다. 
반면 송신자가 경로 사이에 혼잡을 감지하면 송신자는 손신율을 줄입니다. 
그러나 이것은 세 가지 의문을 제기합니다. 

1. TCP 송신자는 자신의 연결에 송신자 전송 트래픽 전송률을 어떻게 감지하는가?
2. TCP 송신자는 자신과 목적지 사이 경로의 혼잡을 어떻게 감지하는가?
3. 송신자는 종단 간의 혼잡을 감지함에 따라 송신율을 변화시키기 위해 어떤 알고리즘을 사용해야 하는가?

### 전송률 감지

먼저 TCP 송신 측에서 동작하는 혼잡 제어 메커니즘은 추가적인 변수인 혼잡 윈도(congestion window)를 추적합니다. 
cwnd로 표시되는 혼잡 윈도는 TCP 송신자가 네트워크로 트래픽을 전송할 수 있는 속도에 제약을 가합니다. 
특히 송신하는 쪽에서 확인응답이 안 된 데이터의 양은 cwnd와 rwnd의 최솟값을 초과하지 않습니다. 

$$ LastByteSent - LastByteAcked \leq min {cwnd, rwnd} $$  


대략 매 왕복 시간(RTT)의 시작 때 송신자는 앞에서 언급한 제약 조건에 따라 cwnd 바이트만큼의 데이터를 전송할 수 있고 RTT가 끝나는 시점에 데이터에 대한 확인응답을 수신합니다. 
그러므로 송신자의 송신 속도는 대략 cwnd/RTT 바이트/초입니다. 
cwnd의 값을 조절하여 송신자는 링크에 데이터를 전송하는 속도를 조절할 수 있습니다. 


### 혼잡 감지

타임아웃 또는 수신자로부터 3개의 중복된 ACK의 수신이 발생했을 때 TCP 송신자 측에서 손실 이벤트(loss event)가 발생했다고 정의합니다. 
과도한 혼잡이 발생하면 경로에 있는 하나 이상의 라우터 버퍼들이 오퍼플로되고 그 결과(TCP가 포함된) 데이터그램이 버려집니다. 
버려진 데이터그램은 송신 측에서 손실 이벤트(타임아웃 또는 3개의 중복된 ACK의 수신)를 발생시키고 송신자는 송신자와 수신자 사이의 경로상의 혼잡이 발생했음을 알게 됩니다. 

확인응답이 상대적으로 늦은 속도(예: 종단 간의 경로가 높은 지연을 갖거나 낮은 대역폭 링크를 포함하면)로 도착한다면 혼잡 윈도는 상대적으로 낮은 속도로 증가하는 반면에 확인응답이 높은 속도로 도착한다면 혼잡 윈도는 더 빨리 증가합니다. 
TCP는 확인응답을 혼잡 윈도 크기의 증가를 유발하는 트리거(trigger) 또는 클록(clock)으로 사용하므로 TCP는 자체 클로킹(self-clocking)이라고 합니다. 

### 송신 속도 조절

TCP 송신자들은 네트워크를 혼잡시키지 않고 더 높은 전송률로 보낼 수 있습니다. 
TCP 송신자들은 가용한 대역폭을 모두 사용하는 동시에 반면 네트워크를 혼잡시키지 않는 전송률을 어떻게 결정하는지에 대해서는 아래에서 자세히 설명합니다.  

- 손실된 세그먼트는 혼잡을 의미하며 이에 따라 TCP 전송률은 한 세그먼트를 손실했을 때 줄여아합니다: 타임아웃 이벤트나 4개의 확인응답(하나의 원래의 ACK와 3개의 중복된 ACK)의 수신은 손실 세그먼트의
  재전송을 야기합니다.
  혼잡 제어 관점에서 문제는 TCP 송신자가 혼잡 윈도 크기와 이에 따른 추론된 손실 이벤트에 대응하는 전송률을 줄이는 방법입니다.
- 확인응답된 세그먼트는 네트워크가 송신자의 세그먼트를 수신자에게 전송된다는 것이고 이에 따라 이전에 확인응답되지 않은 세그먼트에 대해 ACK가 도착하면 송신자의 전송률은 중가할 수 있습니다: 확인응답의 도착은
  세그먼트들이 송신자로부터 수신자까지 성공적으로 전송되었고 네트워크는 혼잡하지 않다는 묵시적 표시로 받아들여집니다.
  따라서 혼잡 윈도 크기가 증가할 수 있습니다.
- 대역폭 탐색:  TCP는 송신자로 하여금 손실 이벤트가 발생할 때까지는 ACK가 도착함에 따라 전송률을 증가시키게 하는 것이고 손실 이벤트가 발생한 시점에서 전송률을 줄이는 것입니다.
  그러므로 TCP 송신자는 혼잡이 발생하는 시점까지 전송률을 증가시키고(전송률을 탐색) 그 시점 이후부터는 줄인 후 다시 혼잡 시작이 발생했는지를 보기 위한 탐색을 시작합니다.
  네트워크에 의한 혼잡 상태의 어떠한 명시적인 신호가 없으며(ACK와 손실 이벤트는 묵시적 신호) 각 TCP 송신자들은 다른 TCP 송신자들과는 비동기적으로 로컬 정보에 근거해 동작합니다. 

## TCP 혼잡 제어 알고리즘(TCP congestion-control algorithm)

TCP 혼잡 제어에 대한 위와 같은 개념을 바탕으로 TCP 혼잡 제어 알고리즘을 상세히 고려할 수 있습니다. 
이 알고리즘은 다음과 같은 중요한 세 가지 구성 요소를 갖습니다. 

1. 슬로 스타트(slow start)
2. 혼잡 회피(congestion avoidance)
3. 빠른 회복(fast recovery)

슬로 스타트와 혼잡 회피는 TCP의 필수 요소이며 다만 수신된 ACK에 대응하여 cwnd 크기를 얼마나 증가시키느냐는 것이 서로 다릅니다. 
이름과 대조적으로 슬로 스타트는 혼잡 회피보다 더 빨리 cwnd 크기를 증가 시킵니다. 
빠른 회복은 권고되지만 TCP 송신자들에게는 필수 사항은 아닙니다. 

### 슬로 스타트 

TCP 연결이 시작될 때 cwnd의 값은 일반적으로 1 MSS(maximum segment size)로 초기화되고 그 결과 초기 전송률은 대략 MSS/MTT가 됩니다(RFC 3390). 
TCP 송신자에게 가용 대역폭은 MSS/RTT보다 훨씬 클 것이므로 TCP 송신자는 가용 대역폭 양을 조속히 찾고자합니다. 
그러므로 슬로 스타트 상태에서는 cwnd 값을 1 MSS에서 시작하여 한 전송 세그먼트가 첫 번째로 확인응답을 받을 때마다 1 MSS씩 증가합니다. 
확인응답이 도착하면 TCP 송신자는 하나의 MSS만큼 혼잡 윈도를 증가시키고 2개의 MSS를 전송합니다. 
이 세그먼트가 확인응답하면 송신자는 각 확인응답 세그먼트에 대해 하나의 MSS만큼 혼잡 윈도를 증가시킵니다. 
그러면 4개의 MSS 혼잡 윈도가 주어지게 되고 이러한 과정은 계속됩니다. 
그래서 TCP 전송률은 작은 값으로 시작하지만 슬로 스타트 단계 동안에 **지수적**으로 증가하게 됩니다.  

![slow-start-graph](/assets/img/computer-science/network/transport-layer/slow_start_graph.png)  

[출처](https://packetlife.net/blog/2011/jul/5/tcp-slow-start/)  

그러나 이 지수적 증가는 다음과 같은 몇 가지 경우에 종료됩니다.  

만약 타임아웃으로 표시되는 손실 이벤트(혼잡)가 있을 경우 TCP 송신자는 cwnd 값을 1로 설정하고 새로운 슬로우 스타트를 시작합니다. 
또한 TCP 송신자는 두 번째 상태 변수인 ssthresh(slow start threshold(슬로우 스타트 임곗값)의 값을 cwnd/2(혼잡이 검출되었을 시점에서의 혼잡 윈도 값의 반)로 설정합니다. 
ssthresh 값에 도달하거나 지나칠 때 cwnd를 계속 두 배로 하는 것은 신중하지 못한 일이기 때문에 cwnd 값이 ssthresh 값과 같으면 슬로 스타트는 종료되고 TCP는 혼잡 회피 모드로 전환합니다. 

또 다른 경우는 만약 3개의 중복 ACK가 검출되면 TCP는 빠른 재전송을 수행하여 빠른 회복 상태로 들어갑니다. 

### 혼잡 회피

혼잡 회피 상태로 들어가는 시점에서 cwnd의 값은 대략 혼잡이 마지막으로 발견된 시점(혼잡이 거의 목전에 있을 때)에서의 값의 반이 됩니다. 
그러므로 RTT마다 cwnd 값을 두 배로 하기보다는 TCP는 좀 더 보수적인 접근법을 채택하여 RTT마다 하나의 MSS만큼 cwnd 값을 증가시킵니다. 
일반적인 접근 방식은 새로운 승인이 도착할 때마다 TCP 송신자가 cwnd를 MSS바이트(MSS/cwnd)만큼 증가시키는 것입니다. 
예를 들어 MSS가 1,460 바이트고 cwnd가 14,600 바이트일 때 10개의 세그먼트가 한 RTT 내에 송신될 수 있습니다. 
각 ACK(세그먼트당 하나의 ACK)는 1/10 MSS만큼 씩 혼잡 윈도를 증가시키고 이에 따라 모든 10개의 세그먼트가 수신되었을 때의 ACK들 후에 하나의 MSS만큼만 혼잡 윈도 값을 증가시킵니다. 

그러나 이 혼잡 회피의 선형 증가가는 다음과 같은 몇 가지 경우에 종료됩니다. 

TCP 혼잡 회피 알고리즘은 타임아웃이 발생했을 때 슬로 스타트의 경우와 같이 동작합니다. 
cwnd의 값은 1 MSS로 설정하고 ssthresh의 값은 손실 이벤트가 발생할 때의 cwnd 값의 반으로 설정합니다. 
그러나 3개의 중복된 ACK 손실 이벤트 경우에는 TCP 타임아웃 표시 손실보다 덜 과감해야합니다. 
TCP는 3개의 중복 ACK를 수신한 시점에서 cwnd의 값을 반으로 줄이고(수신된 3개의 중복 ACK를 설명하기 위해 3 MSS 더함) ssthresh 값을 cwnd 값의 반으로 기록 후 빠른 회복 상태로 들어갑니다. 

### 빠른 회복

빠른 회복에서는 cwnd 값을 손실된 세그먼트(TCP를 빠른 회복 상태로 들어가게 했던 세그먼트)에 대해 수신된 모든 중복된 ACK에 대해 1 MSS 만큼 증가시킵니다. 
손실된 세그먼트에 대한 ACK가 도착하면 TCP는 cwnd 혼잡 회피 상태로 들어갑니다. 
만약 타임 아웃 이벤트가 발생한다면 빠른 회복은 슬로 스타트 및 혼잡 회피에서와 같은 동작을 수행한 후 슬로 스타트로 전이합니다. 
즉 cwnd 값은 1 MSS로하고 ssthresh 값은 손실 이벤트가 발생할 때의 cwnd 값의 반으로 합니다. 

TCP 타호(TCP Tahoe)라 불리는 초기 TCP 버전은 타임아웃으로 표시되거나 3개의 중복 ACK로 표시되는 손실이 발생하면 무조건 혼잡 윈도를 1 MSS로 줄이고 슬로 스타트 단계로 들어갑니다. 
새로운 TCP 버전인 TCP 리노(TCP Reno)는 빠른 회복을 채택했습니다. 

![tahoe-reno-graph](/assets/img/computer-science/network/transport-layer/tahoe-reno-graph.png)   

[출처](https://commons.wikimedia.org/wiki/File:CongWin_in_TCP_Tahoe_e_Reno.png)  

처음 8번의 전송 동안에는 타호와 리노가 동일한 행동을 취합니다. 
혼잡 윈도는 슬로 스타트 동안에 지수적으로 빠르게 증가하고 4번째 송신에서 임곗값에 이릅니다. 
8번째 송신 후에 3개의 중복 ACK가 발생할 때까지 혼잡 윈도는 선형으로 증가합니다. 
손실 이벤트가 발생한 8번째 송신에서 TCP 리노에서는 혼잡 윈도가 9 MSS로 설정되고 선형적으로 증가합니다. 
TCP 타호에서 혼잡 윈도는 1 MSS로 설ㅈ어되고 sshtresh에 도달할 때까지 지수적으로 ㅈ으가하며 그 이후에는 선형적으로 증가합니다. 

### 큐빅

TCP 큐빅(TCP CUBIC)은 패킷 손실 발생 임곗값보다 바로 아래의 패킷 전송 속도를 탐색하는 가장 좋은 대안으로 나온 알고리즘입니다. 
패킷 손실이 발생한 혼잡한 링크의 상태가 많이 변경되지 않은 경우 전송 속도를 더 빠르게 높여 손실 전 전송 속도에 근접한 다음 대역폭을 신중하게 조사하는 특징을 가지고 있습니다. 
ACK 수신 시에만 혼잡 윈도를 늘리고 슬로 스타트 단계와 빠른 복구 단계는 동일하게 유지되지만 큐빅은 다음과 같이 혼잡 회피 단계가 수정되었습니다. 

슬로 스타트 단계가 끝나는 시점에서 혼잡 손실이 발생하면 큐빅은 혼잡 제어 윈도 크기에 가깝게 더 빠르게 증가합니다. 
TCP 큐빅은 혼잡 임곗값 바로 아래에서 가능한 한 오랫동안 흐름을 유지하려고 시도합니다. 

![reno-and-cubic](/assets/img/computer-science/network/transport-layer/reno-and-cubic.png) 

[출처](https://www.chegg.com/homework-help/questions-and-answers/consider-figure-354-suppose-t3-sending-rate-congestion-loss-next-occurs-drops-075-wmax-unb-q57391432)

해당 글은 [컴퓨터 네트워킹 하향식 접근(James F. Kurose, Keith W. Ross)](https://www.yes24.com/Product/Goods/45543957)을 읽고 공부한 내용을 정리한 글입니다.  

오탈자 및 오류 내용을 댓글 또는 메일로 알려주시면, 검토 후 조치하겠습니다.
