---
title: CPU의 구조와 기능
date: 2023-05-29 00:10:00 +09:00
categories: [ Computer Science, Computer Structure ]
tags: [ CPU ]
math: true
---

# CPU의 구조와 기능

CPU는 기억장치에 저장되어 있는 프로그램 코드인 명령어들을 실햄함으로써 **프로그램 수행**이라는 컴퓨터의 기본적인 기능을 수행하는데, 그를 위하여 CPU가 수행해야 하는 세부적인 동작들을 순서대로 나열하면 다음과
같습니다.

1. 명령어 인출(Instruction fetch): 기억장치로부터 명령어를 읽어옵니다.
2. 명령어 해독(Instruction decode): 수행해야 할 동작을 결정하기 위하여 명령어를 해독합니다.
3. 데이터 인출(Data fetch): 명령어 실행을 위하여 데이터가 필요한 경우에는 기억장치 혹은 I/O 장치로부터 그 데이터를 읽어옵니다.
4. 데이터 처리(Data process): 데이터에 대한 산술적 혹은 논리적 연산을 수행합니다.
5. 데이터 저장(Data store): 수행한 결과를 저장합니다.

위 동작들 중에서 첫 번째 및 두 번쨰 동작은 모든 명령어들에 대하여 공통적으로 수행되지만, 세 번째부터 다섯 번째까지의 동작들은 명령어에 따라 필요한 경우에만 수행됩니다.
위와 같은 동작들을 수행하기 위하여 CPU가 포함해야 하는 내부 구성요소들을 상펴본 다음에, 명령어 실행 과정의 분석을 통하여 CPU의 동작 원리를 설명하겠습니다.
추가로 명령어 실행 속도를 높이기 위한 주요 기술인 파이프라이닝(pipelining)의 원리와 명령어 형식에 대해서도 분석하겠습니다.

# CPU의 기본 구조

CPU는 산술논리연산장치(Arithmetic and Logical Unit: ALU))와 레지스터 세트(register set) 및 제어 유닛(control unit)으로 구성됩니다.

## ALU

ALU는 각종 산술 연산들과 논리 연산들을 수행하는 회로들로 이루어진 하드웨어 모듈입니다.
사칙연산의 산술 연산과 AND, OR, NOT 연산 등이 있는 논리 연산으로 구성되어 있습니다.

## 레지스터

CPU 내부에 위치한 기억장치로서, 엑세스 속도가 컴퓨터의 기억장치들 중에서 가장 빠릅니다. 그러나 레지스터는 내부 회로가 복잡하여 비교적 큰 공간을 차지하기 때문에, 많은 수의 레지스터들을 CPU의 내부에
포함시키기는 어렵습니다.

## 제어 유닛

프로그램 코드(명령어)를 해석하고, 그것을 실행하기 위한 제어 신호들(control signals)을 순차적으로 발생하는 하드웨어 모듈입니다.
즉, 명령어 실행에 필요한 각종 정보들의 전송 통로와 방향을 지정해주고, CPU 내부 요소들과 시스템 구성 요소들의 동작 시간도 결정합니다.
CPU가 제공하는 명령어들의 수가 많아질수록 제어 유닛의 내부 회로는 더 복잡해지는데, 복잡도를 줄이기 위하여 제어 유닛의 동작을 소프트웨어로 처리해주는 방법이 마이크로프로그래밍(microprogramming)
입니다.
하지만 이 방법을 이용하면 명령어 실행 시간이 길어지기 때문에, 최근에는 명령어의 수를 가능한 줄이고 명령어 형식을 단순화함으로써, 하드웨어만으로 명령어를 실행할 수 있도록 하는 RISC(Reduced
Instruction Set Computer) 설계 개념도 많이 사용되고 있습니다.

![cpu-structure-bus](/assets/img/computer-science/cpu/cpu-structure-bus.png)

# 명령어 실행

CPU는 기억장치에 저장되어 있는 명령어들을 **인출**하여 **실행**함으로써 실제적인 작업을 수행합니다.
CPU가 한 개의 명령어를 실행하는 데 필요한 전체 과정을 명령어 사이클(instruction cycle)이라고 합니다.
CPU가 기억장치로부터 명령어를 읽어 오는 명령어 인출(instruction fetch) 단계와 인출된 명령어를 실행하는 명령어 실행(instruction execution) 단계로 이루어집니다.

![instruction-cycle](/assets/img/computer-science/cpu/instruction-cycle.png)

명령어를 실행하기 위하여 기본적으로 필요한 CPU 내부 레지스터들을 살펴 보면 아래와 같습니다.

- 프로그램 카운터(Program Counter: PC): 다음에 인출될 명령어의 주소를 가지고 있는 레지스터입니다. 각 명령어가 인출된 후에는 그 내용이 자동적으로 1(혹은 명령어 길이에 해당하는 주소 단위의
  수만큼)이 증가되며, 분기(branch) 명령어가 실행되는 경우에는 그 목적지 주소로 갱신됩니다.
- 누산기(Accumulator: AC): 데이터를 일시적으로 저장하는 레지스터입니다. 이 레지스터의 비트 수는 CPU가 한 번에 연산 처리할 수 있는 데이터 비트의 수, 즉 단어의 길이와 같습니다.
- 명령어 레지스터(Instruction Register: IR): 가장 최근에 인출된 명령어가 저장되어 있는 레지스터입니다.
- 기억장치 주소 레지스터(Memory Address Register: MAR): PC에 저장된 명령어 주소가 시스템 주소 버스로 출력되기 전에 일시적으로 저장되는 주소 레지스터로 이 레지스터의 출력 선들이 주소
  버스 선들과 직접 접속됩니다.
- 기억장치 버퍼 레지스터(Memory Buffer Register: MBR): 기억장치에 저장될 데이터 혹은 기억장치로부터 읽혀진 데이터가 일시적으로 저장되는 버퍼 레지스터로 입력 및 출력 선들은 데이터 버스
  선들과 직접 접속됩니다.

![register-data-bus](/assets/img/computer-science/cpu/register-data-bus.png)

## 인출 사이클

CPU는 각 명령어 사이클의 시작 단계에서 프로그램 카운터(PC)가 가리키는 기억장치의 위치로부터 명령어를 인출해 온다.
그럼 다음에 CPU는 PC의 내용을 1씩 증가시킴으로써 명령어들을 기억장치에 저장되어 있는 순서대로 읽어 올 수 있도록 해준다.

인출 사이클에서 각 단계별로 수행되는 동작을 마이크로-연산(micro-operation)으로 표현하면 다음과 같습니다.

| **주기**  |                     **동작**                      |
|:-------:|:-----------------------------------------------:| 
| $t_{0}$ |               MAR $\leftarrow$ PC               |   
| $t_{1}$ | MBR $\leftarrow$ M[MAR], PC $\leftarrow$ PC + 1 |   
| $t_{2}$ |                       MBR                       |   

여기서 $t_{0}$ , $t_{1}$ 및 $t_{2}$는 CPU 클록의 각 주기를 가리킵니다. 
즉, 명령어 인출에는 세 개의 CPU 클록 주기만큼 시간이 걸립니다. 
인출 사이클에서 가장 먼저 수행되는 동작은 현재의 PC 내용을 CPU 내부 버스를 통하여 MAR로 보내는 것입니다. 
그렇게 되면, 시스템 주소 버스와 직접 접속된 MAR을 통하여 주소가 기억장치로 전송됩니다. 

두 번째 주기에서는 그 주소가 지정하는 기억장치 위치로부터 읽혀진 ㅁ여령어가 데이터 버스를 통하여 MBR로 적재되며, 그와 동시에 PC의 내용에 1을 더하여 다음 명령어 주소를 가리키게 합니다. 
만약 기억장치 주소가 바이트 단위고 명령어 길이는 16비트라면, 한 명령어는 두 개의 주소에 걸쳐 저장되어 한 명령어를 읽은 다음에 PC의 내용에 2를 더해야 다음 명령어가 저장된 위치를 지정할 수 있게 됩니다.  

마지막 세 번째 주기에서는 MBR에 저장되어 있는 명령어 코드가 명령어 레지스터인 IR로 이동됩니다. 

해당 글은 [컴퓨터구조론(김종현 저)](http://www.yes24.com/Product/Goods/69761003)을 읽고 공부한 내용을 정리한 글입니다.

오탈자 및 오류 내용을 댓글 또는 메일로 알려주시면, 검토 후 조치하겠습니다. 
