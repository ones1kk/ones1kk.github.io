---
title: JVM(Java Virtual Machine)
date: 2023-06-30 00:01:00 +09:00
categories: [ Language, Java ]
tags: [ Java, JVM ]
---

# JVM

자바(Java) 언어의 실행 환경인 JVM(Java Virtual Machine)은 자바 바이트코드를 실행하는 가상 컴퓨터입니다.
JVM는 다양한 플랫폼에서 자바 코드의 호환성을 보장합니다.
JVM에 대한 글을 작성하기 전에 먼저 자바에 대해 간단히 알아 보겠습니다.

## Java

자바는 1995년에 최초로 공개되었으며 현재 가장 널리 사용되는 프로그래밍 언어 중 하나로 다양한 플랫폼에서 사용할 수 있는 유연하고 강력한 프로그래밍 언어입니다.
자바는 "Write once, run anywhere"라는 슬로건을 내세워 여러 플랫폼에서 동일한 코드를 실행할 수 있는 것이 당시 프로그래밍 언어와의 큰 차이 중 하나였습니다.
자바는 웹 애플리케이션 개발을 위한 서블릿(Servlet)과 JavaServer Pages(JSP) 등의 기술을 도입하여 대규모 엔터프라이즈 시스템에서도 성능과 확장성을 보장하였습니다.
또한 자바는 객체지향 프로그래밍 언어로서의 특징도 가지며 자동 메모리 관리를 위한 가비지 컬렉션(Garbage Collection) 기능을 제공합니다.

## 특징

자바의 주요 특징은 다음과 같습니다.

### 객체 지향 프로그래밍(OOP: Object-Oriented Programming))

- 클래스(Class)와 객체(Object): 자바는 객체의 설계도인 클래스를 기반으로 생성된 실체인 객체를 생성하여 프로그램을 구성합니다.객체는 상태(state)와 동작(behavior)을 가지며, 데이터와
  메소드로 구성됩니다.
- 캡슐화(Encapsulation): 자바는 캡슐화를 통해 데이터의 접근을 제어하고, 데이터의 무결성과 보안을 유지할 수 있습니다.
- 상속(Inheritance): 상속은 클래스 간에 부모-자식 관계를 형성하여 부모 클래스의 특성과 동작을 자식 클래스가 상속받을 수 있는 기능입니다. 상속을 통해 계층적인 구조를 만들어 객체의 관계를 표현할 수
  있습니다.
- 다형성(Polymorphism): 다형성은 하나의 객체가 여러 가지 타입을 가질 수 있는 능력을 의미합니다. 자바에서는 다형성을 인터페이스와 상속을 통해 구현할 수 있습니다. 이를 통해 코드의 유연성과 확장성을
  높일 수 있습니다.
- 추상화(Abstraction): 추상화는 객체의 공통적인 특성을 추출하여 모델화하는 과정입니다. 자바에서는 추상 클래스(abstract class)와 인터페이스를 활용한 추상화를 통해 복잡한 시스템을 단순화하고
  구조화할 수 있습니다.

### 절차 지향 프로그래밍(PP: Procedure Programming)

자바는 ``Ruby, Scala, Smalltalk`` 등 과 같은 순수 객체 지향 프로그래밍 언어가 아닌 절차 지향 프로그래밍 언어 특징도 지니고 있습니다.
아래와 같은 특징은 자바가 순수 객체 지향 언어가 아닌 이유입니다.

- 기본 자료형(Primitive Type)과 래퍼 클래스(Wrapper Class): 자바는 기본 자료형과 그에 대응하는 래퍼 클래스를 함께 제공합니다. 이로 인해 기본 자료형과 객체 간에 변환 작업이 필요하며,
  객체 지향적인 특징이 상쇄될 수 있습니다. 또한 기본 자료형은 메모리 사용과 성능 면에서 유리하지만, 객체로 다루지 않기 때문에 순수한 객체 지향적인 접근이 어렵다는 한계가 있습니다.
- 정적(Static) 멤버: 자바는 정적 변수와 정적 메소드를 지원합니다. 이러한 정적 멤버는 인스턴스의 생성 없이 호출이 가능하며 정적 멤버의 사용은 전역적인 상태를 유지하고 공유할 수 있으므로 이는 객체
  지향적인 설계 원칙과의 충돌을 야기할 수 있습니다.
- 절차 지향적인 요소: 자바에는 절차적인 흐름 제어 구조인 조건문(if-else, switch)과 반복문(for, while)과 같은 절차 지향적인 요소를 가지고 있습니다.

### 메모리 관리

자바는 가비지 컬렉션를 통해 더 이상 사용되지 않는 객체를 자동으로 식별하고 메모리에서 해제합니다.
GC는 프로그램 실행 중에 동적으로 할당된 객체들을 추적하고, 참조되지 않는 객체들을 자동으로 정리하여 사용 가능한 메모리 공간을 유지합니다.
또한 자바의 객체는 동적으로 힙 메모리 영역에 할당됩니다. 힙 메모리는 GC의 관리 대상입니다.
객체가 더 이상 필요하지 않을 때 해당 객체와 그에 속한 메모리는 자동으로 회수되어 재사용 가능한 상태로 유지합니다.

# JVM 구성

먼저 JVM은 JRE(Java Runtime Environment)에 구성되어 있으며 JRE는 JDK(Java Development Kit)에 구성되어 있습니다.
해당 내용을 그림으로 정리하면 아래와 같습니다.

-- 내용 추가해야함 --

![jdk.png](/assets/img/language/java/jvm/jdk.png)

> [출처](https://www.geeksforgeeks.org/differences-jdk-jre-jvm/)

-- 내용 추가해야함 --

자바 프로그램을 실행시키면 JVM은 아래와 같은 단계를 거쳐 동작합니다.

1. 컴파일: 자바 소스 컴파일러(javac)가 자바 소스 코드(.java)를 컴파일하면서 소스 코드의 구문 오류를 확인하고 자바 바이트 코드(.class)로 변환합니다.
2. 클래스 로딩: 컴파일 된 자바 바이트 코드를 JVM의 Class Loader를 통해 필요한 클래스 파일을 Runtime Data Areas로 클래 로드합니다.
3. 메소드 영역 초기화: 클래스 로딩이 완료되면 Method Area을 초기화합니다. 클래스의 정적 변수(static variable)와 클래스 메소드(static method)가 메모리에 할당됩니다.
4. main 메소드 실행: main 메소드는 프로그램의 진입점(entry point)으로, JVM은 main 메소드를 찾아 프로그램을 실행합니다.
5. 스택 영역 생성: 스택 영역은 각 스레드마다 하나씩 존재하며 스레드가 시작될 떄 할당됩니다. 각각의 메소드 호출은 스택 프레임(stack frame)을 생성하여 메모리에 할당합니다.
6. 바이트 코드 실행: JVM은 Execution Engine을 사용하여 바이트코드를 해석하고 실행합니다. Execution Engine은 바이트 코드를 하나씩 읽어서 해석하고, 인터프리터 또는 JIT 컴파일러(
   Just-in-Time Compiler)를
   통해 실행합니다. Execution Engine은 프로그램의 흐름을 제어하며 바이트 코드를 실행합니다.
7. 메모리 관리: JVM은 가비지 컬렉션를 통해 사용하지 않는 객체를 자동으로 정리합니다. 가비지 컬렉션는 힙 영역에서 메모리를 회수하여 재사용 가능한 상태로 만듭니다.

# JVM 구조

다음은 JVM의 구조를 상세하게 그린 도식입니다.

![jdk-architecture](/assets/img/language/java/jvm/jvm-architecture.png)   

> [출처](https://dzone.com/articles/jvm-architecture-explained)  

## Class Loader

Runtime에 자바 바이트 코드를 JVM 메모리로 동적 로딩

- Loading(Creating)
- Linking(Verification, Preparation, Resolution)
- Initialization

필요할 떄마다 필요한 클래스/리소스만 로딩

## Execution Engine

메모리 영역에 있는 데이터를 가져와 해당하는 작업 수행

자바는 인터프리트, 컴파일 두 방식을 혼합하여 사용하는 하이브리드 모델
javac를 이용해 소스 코드를 바이트 코드로 변환
변환된 바이트 코드를 JVM 인터프리터가 분석, 실행

### Interpreter

메모리에 로드된 바이트 코드를 한줄 씩 해석/실행하는 단어 그대로 인퍼프리터

### JIT(Just-in-Time) Compiler

- 자주 호출되는 메소드(Hot Method)의 바이트 코드를 네이티브 코드로 컴파일
- JVM이 실행 메소드를 모니터, JIT 컴파일러의 프로파일러가 수집한 프로파일 정보를 기반으로 처리
- 중간 코드 생성 > 코드 최적화 > 네이티브 코드 생성

### Garbage Collector

- 메모리에서 사용하지 않는 객체를 식별해 삭제하는 프로세스
- 데몬 스레드로 동작(명시적으로 호출해도 즉시 실행되지 않음)

## Runtime Data Areas

프로그램 실행을 위해 사용되는 JVM 메모리 영역

### Method Area

JVM 실행 시 생성되며 클래스의 구조나 정보를 저장하는 영역

### Heap

JVM 실행 시 생성되며 모든 객체 인스턴스/배열에 대한 메모리가 할당되는 영역

### PC Register

스레드 별로 생성되며 실행 중인 명령(오프셋)을 저장하는 영역

### JVM Stack

스레드 별로 생성되며 메소드 실행 관련 정보를 저장하는 영역(프레임 저장)

### Native Method Stack

스레드 별로 생성되며 네이티브 코드 실행에 관련 정보를 저장하는 영역

## JNI - Native Method Interface

- JVM과 네이티브 라이브러리 간 이진 호환성을 위한 인터페이스
- 네이티브 메소드(네이티브 언어 C/C++ 등으로 작성) 호출, 데이터 전달과 메모리 관리 수행

## Native Method Library

네이티브 메소드의 구현체를 포함한 플랫폼별 라이브러리

오탈자 및 오류 내용을 댓글 또는 메일로 알려주시면, 검토 후 조치하겠습니다. 
