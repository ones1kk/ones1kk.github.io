---
title: JVM(Java Virtual Machine)
date: 2023-06-30 00:01:00 +09:00
categories: [ Language, Java ]
tags: [ Java, JVM, JDK, JRE ]
---

# JVM

자바(Java) 언어의 실행 환경인 JVM(Java Virtual Machine)은 자바 바이트코드를 실행하는 가상 컴퓨터입니다.
JVM은 말 그대로 가상 기계, 즉 가상의 컴퓨터를 물리적 컴퓨터의 메모리 안에 하나 더 구축합니다.
가상이긴 하지만 새로운 가상 컴퓨터를 구축하다보니 더 많은 물리적 CPU 자원과 메모리를 소비하기 때문에 당시 프로그래밍 언어들과 속도를 비교했을 때는 많이 느렸습니다.
하지만 하드웨어의 발전, 하드웨어 구성 요소의 가격 하락, 최적화된 알고리즘으로 개발된 API와 JVM으로 인해 현재는 자바의 성능이 느린 것을 체감하기는 힘듭니다.  
자바의 가상 세계는 현실 세계에서 컴퓨터의 물리적인 하드웨어와 운영체제 그리고 그 위에서 구동될 소프트웨어를 가지는 구조를 모방하여 구성되어 있습니다.

|  Computer   |    JAVA     |            |
|:-----------:|:-----------:|------------|
| 소프트웨어 개발 도구 | JDK - 개발 도구 | JVM용 개발 도구 |
|    운영체제     | JRE - 실행환경  | JVM용 OS    |
|    하드웨어     | JVM - 가상 기계 | 가상 컴퓨터     |

JVM에 대한 글을 작성하기 전에 먼저 자바에 대한 내용을 간단히 알아보겠습니다.

<details>
<summary>접기/펼치기</summary>
<div markdown="1">

## Java

자바는 1995년에 최초로 공개되었으며 현재 가장 널리 사용되는 프로그래밍 언어 중 하나로 다양한 플랫폼에서 사용할 수 있는 유연하고 강력한 프로그래밍 언어입니다.
자바는 "Write Once, Run Anywhere" 라는 슬로건을 내세워 여러 플랫폼에서 동일한 코드를 실행할 수 있는 것이 당시 프로그래밍 언어와의 큰 차이 중 하나였습니다.
자바는 웹 애플리케이션 개발을 위한 서블릿(Servlet)과 JavaServer Pages(JSP) 등의 기술을 도입하여 대규모 엔터프라이즈 시스템에서도 성능과 확장성을 보장하였습니다.
또한 자바는 객체지향 프로그래밍 언어로서의 특징도 가지며 자동 메모리 관리를 위한 가비지 컬렉션(Garbage Collection) 기능을 제공합니다.

## 특징

자바의 주요 특징은 다음과 같습니다.

### 객체 지향 프로그래밍(OOP: Object-Oriented Programming))

- 클래스(Class)와 객체(Object): 자바는 객체의 설계도인 클래스를 기반으로 생성된 실체인 객체를 생성하여 프로그램을 구성합니다.객체는 상태(state)와 동작(behavior)을 가지며, 데이터와
  메소드로 구성됩니다.
- 캡슐화(Encapsulation): 자바는 캡슐화를 통해 데이터의 접근을 제어하고, 데이터의 무결성과 보안을 유지할 수 있습니다.
- 상속(Inheritance): 상속은 클래스 간에 부모-자식 관계를 형성하여 부모 클래스의 특성과 동작을 자식 클래스가 상속받을 수 있는 기능입니다. 상속을 통해 계층적인 구조를 만들어 객체의 관계를 표현할 수
  있습니다.
- 다형성(Polymorphism): 다형성은 하나의 객체가 여러 가지 타입을 가질 수 있는 능력을 의미합니다. 자바에서는 다형성을 인터페이스와 상속을 통해 구현할 수 있습니다. 이를 통해 코드의 유연성과 확장성을
  높일 수 있습니다.
- 추상화(Abstraction): 추상화는 객체의 공통적인 특성을 추출하여 모델화하는 과정입니다. 자바에서는 추상 클래스(abstract class)와 인터페이스를 활용한 추상화를 통해 복잡한 시스템을 단순화하고
  구조화할 수 있습니다.

### 절차적/구조적 프로그래밍(PP: Procedure Programming, SP: Structured Programing)

객체 지향 프로그래밍은 절차적/구조적 프로그램의 많은 부분에서부터 유래되었습니다.
따라서 객체 지향 언어를 이해하는 데 절차적/구조적 프로그래밍을 이해하는 것은 큰 도움이 됩니다.  
절차적 프로그래밍을 한마디로 표현하자면 ``goto``의 사용을 금한다는 것입니다. ``goto``를 사용하게 되면 프로그램의 실행 순서가 인간이 이해하기에는 복잡해 혼란을 야기합니다.
그러한 이유로 자바는 ``goto``를 예약어로 등록해 놓는 것뿐만 아닌 사용하지 못하게끔 선점해놓았습니다.
그리고 구조적 프로그래밍의 가장 큰 특징은 **함수**의 사용입니다. 함수는 중복 코드를 한 곳에 모아 관리 할 수 있고 논리를 함수 단위로 분리해서 이해하기 쉬운 코드를 작성할 수 있기 때문입니다.
추가로 공유 사용 시 문제가 발생하기 쉬운 전역 변수보다는 지역 변수 사용을 지향하라는 지침도 있습니다.

또한 자바가 지키지 못한 순수 객체 지향 언어의 특징은 아래와 같이 있습니다.

- 기본 자료형(Primitive Type)과 래퍼 클래스(Wrapper Class): 자바는 기본 자료형과 그에 대응하는 래퍼 클래스를 함께 제공합니다. 이로 인해 기본 자료형과 객체 간에 변환 작업이 필요하며,
  객체 지향적인 특징이 상쇄될 수 있습니다. 또한 기본 자료형은 메모리 사용과 성능 면에서 유리하지만, 객체로 다루지 않기 때문에 순수한 객체 지향적인 접근이 어렵다는 한계가 있습니다.
- 정적(Static) 멤버: 자바는 정적 변수와 정적 메소드를 지원합니다. 이러한 정적 멤버는 인스턴스의 생성 없이 호출이 가능하며 정적 멤버의 사용은 전역적인 상태를 유지하고 공유할 수 있으므로 이는 객체
  지향적인 설계 원칙과의 충돌을 야기할 수 있습니다.
- 절차 지향적인 요소: 자바에는 절차적인 흐름 제어 구조인 조건문(if-else, switch)과 반복문(for, while)과 같은 절차 지향적인 요소를 가지고 있습니다.

### 메모리 관리

자바는 가비지 컬렉션를 통해 더 이상 사용되지 않는 객체를 자동으로 식별하고 메모리에서 해제합니다.
GC는 프로그램 실행 중에 동적으로 할당된 객체들을 추적하고, 참조되지 않는 객체들을 자동으로 정리하여 사용 가능한 메모리 공간을 유지합니다.
또한 자바의 객체는 동적으로 힙 메모리 영역에 할당됩니다. 힙 메모리는 GC의 관리 대상입니다.
객체가 더 이상 필요하지 않을 때 해당 객체와 그에 속한 메모리는 자동으로 회수되어 재사용 가능한 상태로 유지합니다.

</div>
</details>

# JVM 구성

자바 개발 도구인 JDK(Java Development Kit)를 이용해 개발된 프로그램은 JRE(Java Runtime Environment)에 의해 가상 컴퓨터인 JVM 상에서 구동됩니다.
또한 배포 되는 JDK, JRE, JVM은 편의를 위해 JDK가 JRE를 포함하고 다시 JRE는 JVM을 포함하는 형태로 배포됩니다.
해당 내용을 그림으로 정리하면 아래와 같습니다.

![jdk.png](/assets/img/language/java/jvm/jdk.png)

> [출처](https://www.geeksforgeeks.org/differences-jdk-jre-jvm/)

JDK는 자바 소스 컴파일러(javac)를 포함하고 있고, JRE는 자바 프로그램 실행기인 java.exe를 포함하고 있습니다.
자바가 이런 구조를 택한 이유는 기존 언어로 작성한 프로그램은 각 플랫폼(하드웨어와 OS)용으로 배포되는 설치 파일을 따로 준비해야하는 불편함을 없애기 위해서입니다.
이런 구조는 개발자 본인이 사용 중인 플랫폼에서 설치된 JVM용으로 프로그램을 작성하고 배포하면 각 플랫폼에 맞는 JVM이 중재자로서 각 플랫폼에서 구동합니다.
이러한 구성 방식으로 인해 자바의 특성을 "Write Once Run Anywhere"이라고 합니다.

자바 프로그램을 실행시키면 JVM은 아래와 같은 단계를 거쳐 동작합니다.

1. 컴파일: 자바 소스 컴파일러(javac)가 자바 소스 코드(.java)를 컴파일하면서 소스 코드의 구문 오류를 확인하고 자바 바이트 코드(.class)로 변환합니다.
2. 클래스 로드: 컴파일 된 자바 바이트 코드를 JVM의 Class Loader를 통해 필요한 클래스 파일을 Runtime Data Areas로 클래스 로드합니다.
3. 메소드 영역 초기화: 클래스 로딩이 완료되면 Method Area을 초기화합니다. 클래스의 정적 변수(static variable)와 클래스 메소드(static method)가 메모리에 할당됩니다.
4. main 메소드 실행: main 메소드는 프로그램의 진입점(entry point)으로, JVM은 main 메소드를 찾아 프로그램을 실행합니다.
5. 스택 영역 생성: 스택 영역은 각 스레드마다 하나씩 존재하며 스레드가 시작될 떄 할당됩니다. 각각의 메소드 호출은 스택 프레임(stack frame)을 생성하여 메모리에 할당합니다.
6. 바이트 코드 실행: JVM은 Execution Engine을 사용하여 바이트코드를 해석하고 실행합니다. Execution Engine은 바이트 코드를 하나씩 읽어서 해석하고, 인터프리터 또는 JIT 컴파일러(
   Just-in-Time Compiler)를
   통해 실행합니다. Execution Engine은 프로그램의 흐름을 제어하며 바이트 코드를 실행합니다.
7. 메모리 관리: JVM은 가비지 컬렉션를 통해 사용하지 않는 객체를 자동으로 정리합니다. 가비지 컬렉션는 힙 영역에서 메모리를 회수하여 재사용 가능한 상태로 만듭니다.

# JVM 구조

위에서 JVM이 어떤 식으로 구성되어있는지, 자바 프로그램을 실행시키는 순서에 대해 설명했습니다.
지금부터는 JVM의 구조를 살펴보고 JVM의 각각의 요소들의 역활에 대해 알아 보겠습니다.    
다음은 JVM의 구조를 상세하게 그린 도식입니다.

![jvm-architecture](/assets/img/language/java/jvm/jvm-architecture.png)

> [출처](https://www.flowerbrackets.com/preface-to-java-virtual-machine-and-architecture/)

JVM은 크게 Class Loader SubSystem, Runtime Data Areas, Execution Engine, JNI(Native Method Interface), Native Method
Library 영역으로 나누어져있으며 각 부분에 대한 자세한 내용은 아래에서 작성하겠습니다.

## Class Loader SubSystem

![class-loader-subsystem](/assets/img/language/java/jvm/class-loader-subsystem.png)

> [출처](https://chazool.medium.com/jvm-class-loader-subsystem-e6bc4f539066)

클래스 로더(Class Loader SubSystem)는 자바 바이트 코드(.class)를 로드하고 JVM의 메모리 영역인 Runtime Data Areas로 동적 로딩하는 역활을 수행합니다.
클래스 로더는 필요에 따라 클래스 파일을 검색하고 로드하며, 로드된 클래스는 메모리 영역에 할당됩니다.

클래스를 로딩하는 과정은 3단계로 이루어집니다.

- 로드(Loading): 클래스 로딩은 먼저 해당 클래스 파일을 찾아서 메모리에 로드하는 과정입니다. 클래스 로더는 클래스 파일을 파일 시스템, JAR 파일, 네트워크 등에서 찾아옵니다.
- 링크(Linking): 로드된 클래스 파일의 바이트 코드는 아래 3단계의 링크 과정을 거쳐서 최종적으로 실행 가능한 형태로 변환됩니다.
  - 검증(Verification): 클래스 파일의 구조와 유효성을 검사하여 올바른 형식인지 확인합니다. 즉 문법 구문 오류를 찾아내는 역활을 합니다. 문법 오류, 타입 오류, 참조 오류 등을 확인하고 오류가
    있다면 컴파일 오류 메세지를 출력합니다.
  - 준비(Preparation): 클래스의 정적 변수를 위한 메모리 공간을 할당하고 초기값을 설정합니다.
  - 분석(Resolution): 클래스의 상수 풀(Constant Pool)에 있는 심볼릭 레퍼런스들을 실제 메모리 상의 레퍼런스로 변환합니다. 즉 클스 파일의 심볼릭한 참조들이 실제로 실행되는 데 필요한 메모리
    주소와 연결되어 클래스 간의 상호 작용이나 메소드 호출 등을 수행할 수 있습니다.
- 초기화(Initialization): 클래스의 초기화는 정적 변수의 초기화와 정적 블록의 실행을 담당합니다.

또한 클래스 로더는 계층 구조로 이루어져있습니다.

![class-loader-structure](/assets/img/language/java/jvm/class-loader-structure.png)

> [출처](https://chazool.medium.com/jvm-class-loader-subsystem-e6bc4f539066)

클래스 로더는 각 계층마다 역활과 책임이 나눠져있으며 가장 최상위 로더인 부트스트랩 클래스 로더로 부터 시작하여 하위로는 확장 클래스 로더와 애플리케이션 클래스 로더가 순차적으로 실행합니다.
하지만 자바 9 버전부터 모듈 시스템 도입에 맞춰 각각의 클래스 로더의 이름과 범위, 구현 내용등이 바뀌었기 때문에 각 버전에 맞게 설명하겠습니다.

### Java 8

- 부트스트랩 클래스 로더(Bootstrap Class Loader): Native C로 구현되어 있으며 ``jre/lib/rt.jar``에 담긴 JDK 클래스 파일을 로딩합니다.
- 확장 클래스 로더(Extension Class Loader): 자바로 구현되어 있으며 ``jre/lib/ext`` 폴더나 ``java.ext.dirs`` 환경 변수로 지정된 폴더에 있는 클래스 파일을 로딩합니다.
- 애플리케이션 클래스 로더(Application Calss Loader): 자바로 구현되어 있으며 ``-classpath(또는 -cp)``나 JAR 파일 안에 있는 Manifest 파일의 ``Class-Path``
  속성 값으로 지정된 폴더에 있는 클래스를 로딩합니다. 개발자가 애플리케이션 구동을 위해 직접 작성한 대부분의 클래스는 해당 클래스 로더에의해 로딩됩니다.

### Java 9

- 부트스트랩 클래스 로더(Bootstrap Class Loader): ``rt.jar``, ``tools.jar`` 등이 삭제됨에 따라 로딩할 수 있는 클래스의 범위가 전체적으로 축소되었습니다. 또한 이름의 변경
  없이 유지 되었습니다.
- 플랫폼 클래스 로더(Platform Class Loader): ``jre/lib/ext``, ``java.ext.dirs``를 더이상 로딩하지 않고 Java SE의 모든 클래스와 JCP(Java Community
  Process)에 의해 표준화 된 모듈 내의 클래스를 로딩하며 자바 8에 비해 담당 범위가 확장되었습니다. 또한 이름이 변경 되었습니다.
- 시스템 클래스 로더(System ClassLoader): 클래스패스, 모듈패스에 있는 클래스를 로딩합니다. 또한 이름이 변경 되었습니다.

[참고(JDK 9 Migration Guide)](https://docs.oracle.com/javase/9/migrate/toc.htm#JSMIG-GUID-A78CC891-701D-4549-AA4E-B8DD90228B4B)

또 3개의 클래스 로더는 다음 3가지 원칙을 통해 동작합니다.

### Delegation Principle

위임 원칙은 클래스 로드 시 윗방향으로 클래스 로딩을 위임하는 것을 의미합니다.
최초 클래스 로드 요청을 받은 애플리케이션 클래스 로더는 가장 최상위 로더인 부트스트랩 클래스 로더까지 확장 클래스 로더를 걸쳐 클래스 로딩을 요청합니다.
그 후 부트스트랩 클래스 로더에서부터 최하위인 애플리케이션 클래스 로더까지 각자가 담당하는 대상 파일에서 로드 요청이 들어온 클래스를 찾습니다.
각 클래스 로더가 담당하는 클래스 파일일 시 담당 클래스 로더에서 클래스를 반환하지만 3개의 클래스 로더에서 해당 클래스 파일을 찾지 못한다면 ``ClassNotFoundException`` 예외가 발생합니다.

### Visibility Principle

가시성 원칙은 상위 계층의 클래스 로더와 하위 계층의 클래스 로더간의 구분을 위한 원칙으로 하위 클래스 로더는 상위 클래스 로더의 로드 클래스를 볼 수 있지만, 상위 클래스 로더는 반대로 하위 클래스 로더의 로드
클래스를 볼 수 없는 원칙입니다.
가시성 원칙을 통해 각 클래스 로더들은 독립적으로 클래스를 로드할 수 있으며 서로 다른 클래스들 간의 충돌을 방지하고 의존성을 제어할 수 있게 됩니다.

### Uniqueness Principle

유일성 원칙은 각 클래스 로더들이 클래스를 로드할 때 클래스의 유일성을 보장하는 원칙입니다.
하위 클래스 로더는 상위 클래스 로더가 로드한 클래스를 다시 로딩하지 않으며 동일한 이름의 클래스는 동일한 클래스 로더에 의해 한 번만 로드됩니다.
또한 이미 로드한 클래스는 캐싱 되어 다시 요청될 경우 캐싱된 클래스를 반환합니다.

## Execution Engine

![execution-engine](/assets/img/language/java/jvm/execution-engine.png)

Execution Engine은 바이트 코드를 읽고 실제로 실행하는 역활을 담당합니다.
Runtime Data Areas에 있는 자바 바이트 코드를 읽고 운영체제에 맞게 기계어로 번경하여 해당하는 명령어(instruction) 단위로 실행합니다.
Execution Engine은 위의 수행 과정에서 **인터프리터**와 **JIT 컴파일러** 두 가지 방식을 혼합하여 바이트 코드를 실행합니다.

### Interpreter

자바는 인터프리트, 컴파일 두 방식을 혼합하여 사용하는 하이브리드 모델입니다.
컴파일을 통해서 자바 바이트 코드를 생성하고 코드의 명령어를 인터프리터를 사용해 하나씩 읽어서 해석하고 바로 실행합니다.
이는 빠른 시작 속도와 동적인 실행 환경을 제공하지만 반복적으로 실행되는 코드의 성능은 상대적으로 떨어집니다.

### JIT(Just-in-Time) Compiler

인터프리터의 단점을 보완하기 위해 도입된 방식으로 인터프리터가 반복적으로 실행하는 메소드(Hot Method)를 실시간으로 컴파일하여 네이티브 코드(Native Code)로 실행시킵니다.
이렇게 변환된 네이티브 코드는 캐싱 처리되어 이후에 해당 메소드가 실행될 때 재사용됩니다.
이뿐만 아니라 JIT 컴파일러는 프로파일링 정보, 코드 흐름, 하드웨어 정보 등을 활용해 프로그램 실행 중 동적으로 네이티브 코드 최적화를 실행합니다.

- 자주 실행되는 메소드
- 조건문, 반복문, 메서드 호출 등의 제어 흐름
- 하드웨어 정보

JIT 컴파일러는 이러한 실행 환경 정보를 수집하고 분석하여 최적화 전략을 결정합니다.

### Garbage Collection

GC는 Heap 메모리 영역에서 사용하지 않는 객체를 식별하여 메모리를 자동으로 회수합니다.
참조되지 않는 객체를 제거하고 공간을 비우는 이벤트를 "Stop the world"라고 부르며 가비지가 수집될 때까지 모든 애플리케이션의 스레드가 보류됩니다.

일반적으로 GC는 다음 두 단계를 통해 동작합니다.

#### Marking

GC가 사용 중인 객체와 사용하지 않는 객체를 식별하는 단계를 마킹이라고합니다.
사용되지 않는 객체를 식별하기 위해서 모든 객체를 스캔합니다.

![marking-phase](/assets/img/language/java/jvm/marking-phase.png)

> [출처](https://www.tothenew.com/blog/java-garbage-collection-an-overview/)

#### Deletion

삭제 단계에서는 표시된 객체가 삭제되고 메모리가 회수됩니다.
또한 참조되지 않는 객체는 두 가지 방법으로 삭제될 수 있습니다.

1. 일반 삭제(Normal Deletion): 사용되지 않는 모든 객체를 제거하고 새로운 객체를 저장할 수 있게끔 메모리를 할당합니다.
2. 삭제 및 압축(Deletion and Compaction): 성능을 더욱 향상시키기 위해 참조되지 않은 객체를 삭제하는 것 외에도 나머지 참조된 객체를 압축합니다.

GC는 위와 같이 두 단계를 통해 사용되지 않는 객체를 찾아 메모리를 회수합니다.

애플리케이션 실행 시간이 흐름에 따라 점점 많은 객체들이 생성되고 사용됩니다.
하지만 매번 힙 메모리에 있는 모든 객체를 GC가 스캔하는 것은 매우 비효율적이기 때문에 자바는 Heap 메모리를 여러 세대(Generation)으로 나누어 스캔 전략을 관리합니다.  
Heap 메모리는 크게 Young Generation, Old Generation, Permanent Generation(java 8 이후는 Metaspace) 세 가지 세대로 나눕니다.
Young Generation에서 가비지 컬렉션이 발생할 때 살아남은 객체들이 Old Generation으로 이동합니다.
가비지 컬렉션은 Young Generation의 Eden 영역과 Survivor 영역을 스캔하여 살아남은 객체들을 찾고 그 중에서도 메모리 사용량 등과 같은 일정 조건을 충족한 객체들이 Old Generation으로
이동합니다.
이렇게 Heap 메모리를 나누어 관리함으로써 GC는 주로 Young Generation에서 가비지 컬렉션이 빈번하게 발생하며 매번 모든 객체를 스캔해야하는 비효율로부터 벗어날 수 있게 되었습니다.

> 추가로 GC는 데몬 스레드로 동작하기 때문에 명시적으로 호출해도 즉시 실행이 되지 않을 수 있습니다.

## Runtime Data Areas

프로그램 실행을 위해 사용되는 JVM 메모리 영역

### Method Area

JVM 실행 시 생성되며 클래스의 구조나 정보를 저장하는 영역

### Heap

JVM 실행 시 생성되며 모든 객체 인스턴스/배열에 대한 메모리가 할당되는 영역

### PC Register

스레드 별로 생성되며 실행 중인 명령(오프셋)을 저장하는 영역

### JVM Stack

스레드 별로 생성되며 메소드 실행 관련 정보를 저장하는 영역(프레임 저장)

### Native Method Stack

스레드 별로 생성되며 네이티브 코드 실행에 관련 정보를 저장하는 영역

## JNI - Native Method Interface

- JVM과 네이티브 라이브러리 간 이진 호환성을 위한 인터페이스
- 네이티브 메소드(네이티브 언어 C/C++ 등으로 작성) 호출, 데이터 전달과 메모리 관리 수행

## Native Method Library

네이티브 메소드의 구현체를 포함한 플랫폼별 라이브러리

오탈자 및 오류 내용을 댓글 또는 메일로 알려주시면, 검토 후 조치하겠습니다. 
