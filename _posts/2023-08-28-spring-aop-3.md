---
title: Spring AOP(3)
date: 2023-08-27 00:00:00 +09:00
categories: [ Spring Core ]
tags: [ AOP ]
---

# @EnableAspectJAutoProxy

기본적으로 ``ProxyFactory`` 클래스를 사용하여 AOP 프록시를 생성하고 관리할 수 있지만 이는 수동적이며 번거로운 작업입니다. 
그렇기 때문에 Spring은 프록시 생성과 관리의 작업을 자동화하고 추상화한 ``org.springframework.context.annotation.EnableAspectJAutoProxy`` 어노테이션을 제공합니다. 
``@EnableAspectJAutoProxy``는 IoC 컨테이너가 `` org.aspectj.lang.annotation.Aspect``가 적용된 클래스를 스캔하고, 필요한 프록시를 자동으로 생성하여 AOP를 적용할 수 있게끔 설정합니다. 

```java
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Import(AspectJAutoProxyRegistrar.class)
public @interface EnableAspectJAutoProxy {

  /**
   * Indicate whether subclass-based (CGLIB) proxies are to be created as opposed
   * to standard Java interface-based proxies. The default is {@code false}.
   */
  boolean proxyTargetClass() default false;
  
  /**
   * Indicate that the proxy should be exposed by the AOP framework as a {@code ThreadLocal}
   * for retrieval via the {@link org.springframework.aop.framework.AopContext} class.
   * Off by default, i.e. no guarantees that {@code AopContext} access will work.
   * @since 4.3.1
   */
  boolean exposeProxy() default false;
}
```

- proxyTargetClass: AOP Proxy 전략을 설정합니다. 
- 기본 값으로 ``false``이며 CGLIB를 사용하며 ``true``로 변경 시 JDK Dynamic을 사용합니다. 
- exposeProxy: 프록시 객체를 외부로 노출할지를 설정하는 필드입니다. 

# 동작 방식

먼저 동작 방식을 살펴 보기 이전에 Pointcut으로 활용할 어노테이션을 생성합니다. 

```java
@Retention(value = RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface SampleAop {
}
```

그 후 ``@Aspect`` 어노테이션으로 관리할  Advisor 클래스를 생성합니다. 
Advisor는 IoC 컨테이너에서 관리되어야 하기 때문에 Bean으로 등록합니다. 

![sample-aspect](/assets/img/spring/core/aop/sample-aspect.png)  

또한 ``SampleAop`` 어노테이션을 대상 객체 메소드에 작성합니다.

```java
@Service
public class SampleConcreteService {

  @SampleAop
  public String get() {
      return "Hello AOP";
  }
}
```


![sample-concrete-service-test.png](/assets/img/spring/core/aop/sample-concrete-service-test.png) 

위와 같이 설정을 완료 한 후 코드를 실행하여 어떤 식으로 프록시를 생성하며 사용하는지 확인해 보겠습니다. 

## AnnotationAwareAspectJAutoProxyCreator

![annotation-aware-aspectj-auto-proxy-creator.png](/assets/img/spring/core/aop/annotation-aware-aspectj-auto-proxy-creator.png)  
``AnnotationAwareAspectJAutoProxyCreator``는 모든 ``@Aspect`` 어노테이션을 처리하는 ``org.springframework.aop.aspectj.autoproxy.AspectJAwareAdvisorAutoProxyCreator``의 구체 클래스이며 ``@Aspect`` 어노테이션이 선언되어 있는 클래스 스캔하고 해당 클래스를 기반으로 프록시를 생성합니다.  
현재 애플리케이션 컨텍스트의 모든 ``@Aspect`` 뿐만아니라 Spring Advisor도 처리하며 생성된 프록시 객체를 IoC 컨테이너에 빈으로 등록합니다.  

## 동작 순서

애플리케이션이 구동되면  ``AnnotationAwareAspectJAutoProxyCreator``는 먼저 Spring Advisor 후보 클래스들을 스캔합니다. 
만일 존재하지 않는다면 빈 리스트를 반환합니다. 

![find-advisor-beans.png](/assets/img/spring/core/aop/find-advisor-beans.png) 

그 후 반환 받은 Advisors 이 외에 자동 프록시 객체들을 스캔하기 위해 ``BeanFactoryAspectJAdvisorsBuilder.buildAspectJAdvisors()`` 메소드를 실행시킵니다. 

![build-aspectj-advisors.png](/assets/img/spring/core/aop/build-aspectj-advisors.png)

메소드 내부를 확인해보면 IoC 컨테이너에서 관리 중인 빈들을 조회한 후 그 중 ``@Aspect`` 어노테이션이 선언되어 있는 빈들을 찾습니다. 

![is-aspect.png](/assets/img/spring/core/aop/is-aspect.png) 

찾은 ``@Aspect`` 어노테이션이 선언 되어 있는 빈을 찾았다면 해당 빈에서 Advisor를 찾기 위해 ``ReflectiveAspectJAdvisorFactory.getAdvisors()`` 메소드를 통해 계속해서 작업합니다. 

### ReflectiveAspectJAdvisorFactory

``org.springframework.aop.aspectj.annotation.ReflectiveAspectJAdvisorFactory``는 Advice 메소드를 호출하기 위해 리플렉션 API를 사용하여 Advisor를 생성하는 팩토리 클래스입니다. 
식별된 Aspect 클래스의 모든 메소드를 리플렉션 API를 사용하여 추출하고 해당 메소드 하나하나 Advisor인지 확인하고 등록합니다.

![get-advisors.png](/assets/img/spring/core/aop/get-advisors.png)





 








오탈자 및 오류 내용을 댓글 또는 메일로 알려주시면, 검토 후 조치하겠습니다.
