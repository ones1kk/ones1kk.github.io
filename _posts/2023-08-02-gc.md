---
title: 가비지 컬렉션(Garbage Collection)
date: 2023-08-02 00:00:00 +09:00
categories: [ Language, Java ]
tags: [ GC, Garbage-Collection ]
---

# Garbage Collection

GC는 자바의 메모리 관리를 자동화하는 메커니즘으로 명시적으로 메모리를 할당하거나 해제하지 않아도 동적으로 사용하지 않는 객체들을 인식하고 제거하는 프로세스입니다.
GC의 자동 메모리 관리로 인해 프로그래머들은 메모리 누수 문제, 메모리 관리 등과 같은 문제에서 벗어나 오로지 개발에만 집중 할 수 있게 되었습니다. 

하지만 GC는 일시적으로 메모리에 대한 가비지를 수집할 때까지 GC 스레드를 제외한 모든 스레드를 중지하는 Stop the world 이벤트를 진행하는데 이는 오버헤드가 발생돼 프로그램의 응답성이 떨어지는 문제점이 있습니다. 
GC가 오히려 자주 실행되면 프로그램의 실행 시간이 증가되어 성능상의 이슈가 발생합니다.
따라서 실시간으로 제어하는 것이 중요한 프로그램이나 GC가 예상치 못한 타이밍에 발생해 문제를 겪을 수 있는 프로그램같은 경우는 프로그래머들이 직접 메모리를 제어, 관리하는 것이 더 바람직할 수도 있습니다. 

따라서 GC 튜닝을 통해 GC를 효율적으로 실행될 수 있게끔 GC 최적화 작업이 필요합니다. 

# 동작 원리

## 대상

GC 동작 대상은 더이상 사용되지 않는 객체들을 대상으로합니다.
이러한 객체들을 가비지(Garbage)라고 하며 GC의 주요 목표는 이러한 가비지들을 탐지하고 메모리에서 해제하는 것입니다.   

GC는 객체에 대한 **도달가능성(Reachability)** 을 판단하여 가바지 컬렉션 대상을 결정하는데 사용합니다. 
먼저 자바 프로그램은 객체들 사이의 참조(Reference)를 통해 상호 작용합니다.  
이 중 객체에 참조가 남아있다면 **도달 가능한 객체 (Reachable Objects)** 로 구분되어 GC Root로부터 참조 체인을 통해 도달할 수 있는 객체로 구분됩니다. 
반대로 참조가 없다면 **도달 불가능한 객체 (Unreachable Objects)** 로 구분되며 GC Root로부터 참조 체인을 통해 도달할 수 없는 객체로 구분됩니다. 

![gc-root](/assets/img/language/java/gc/gc-root.png)

[출처](https://plumbr.io/handbook/garbage-collection-algorithms/marking-reachable-objects)

GC는 각 영역의 GC Root에서 인스턴스 필드와 다른 객체에 대한 참조를 따라 메모리의 전체 그래프를 순회합니다. 
이때 GC가 방문하는 모든 객체는 활성 상태로 표시되며 GC Root와 연결되지 못한 모든 객체들은 비활성화 상태가 됩니다. 
즉 활성 상태가 된 객체는 도달 가능한 객체로 분류되며 비활성화 상태의 객체는 도달 불가능한 객체로 구분됩니다.  

위와 같이 GC는 주기적으로 GC Root로부터 객체에게 도달 가능한지 여부를 판단하여 도달 가능한 객체들은 해제되지 않은채 유지되며 도달 불가능한 객체들은 GC의 대상이 되어 메모리에서 해제됩니다.

### GC Root

GC Root란 GC의 출발점이 되는 객체를 의미합니다. 
이 객체들은 다른 객체들을 참조하거나 도달 가능한 객체들로부터의 첫 번째 진입점을 제공하여 GC의 시작점으로 동작합니다.   
GC Root로 인식되는 객체들은 다음과 같습니다.

1. 스택프레임(Stack Frame): 스택 프레임에 있는 객체들은 GC Root로 인식됩니다. 스택은 현재 실행 중인 메소드의 상태를 나타내며 실행중인 메소드가 참조하는 객체들은 GC Root로부터 도달 가능한
   상태라고 간주합니다.
2. 정적(Static) 변수: 프로그램의 시작부터 끝까지 존재하기때문에 프로그램 수명 주기 동안 도달 가능한 상태입니다.
3. JNI(Java Native Interface)에서 생성된 객체: 네이티브 코드에서 참조하고 사용되므로 GC가 이러한 객체들을 인식하려면 JNI를 통해 생성된 객체들을 GC Root로 유지해야 합니다.
4. 현재 실행 중인 스레드: 실행 중인 스레드는 객체를 참조할 수 있는 상태를 유지하기 때문에 GC Root로 인식됩니다.

## 동작

GC는 참조 체인을 통해 어떤 객체가 도달 가능한지, 불가능한지 식별합니다. 
그 후 도달 불가능한 객체들의 메모리를 다음과 같이 해제합니다. 

## Mark and Sweep

Mark and Sweep은 GC 알고리즘 중 하나로 동적으로 할당된 메모리 중에서 더 이상 사용되지 않는 객체(도달 불가능한 객체 또는 가비지)를 탐지하여 해제하는 작업을 수행하는 방법입니다. 
먼저 GC 대상 객체를 식별(Mark)하고 제거(Sweep) 후 제거 되어 파편화된 메모리 영역을 앞에서부터 채우게(Compaction) 됩니다.  

1. Mark: GC Root로부터 참조 체인을 통해 도달 가능한 객체를 마킹하며 Mark 단계 이후 마킹되지 않은 객체는 가비지로 간주됩니다. 
2. Sweep: 마킹되지 않은 모든 객체들을 해제하여 메모리를 회수합니다. 해제된 메모리는 다시 사용 가능한 메모리로 표시됩니다.
3. Compact: Mark와 Sweep 단계를 통해 해제된 객체들로 인해 파편화된 메모리를 한쪽으로 모으고 사용 중인 객체들 사이의 빈 공간을 줄여서 메모리 파편화를 해소합니다. Compact 단계 실행 중에 객체들의 상대적인 위치가 변경됨으로 해당 객체들의 포인터도 적절히 업데이트되어야 합니다.

![mark-sweep-compact](/assets/img/language/java/gc/mark-sweep-compact.png)  

[출처](https://www.symphony-solutions.eu/guide-to-garbage-collection-in-programming/)

## 과정

## Minor GC

Minor GC는 Generational Garbage Collection 중 하나로 Young Generation에서 발생하는 GC를 의미합니다.
대부분의 객체는 생성 후 일시적으로 사용되다가 더 이상 참조되지 않게 되는데 이러한 객체들을 관리하기 위한 영역이 Young Generation입니다.
Young Generation은 일반적으로 GC가 더 빈번하게 일어나는데 Old Generation의 크기보다 상대적으로 작기때문에 메모리 상의 객체를 찾아 제거하는데 상대적으로 적은 시간이 걸립니다.

![minor-gc-1](/assets/img/language/java/gc/minor-gc-1.png)   

먼저 Eden 영역은 모든 객체가 최초 생성 시 저장되는 영역으로 첫번째 이미지와 같이 모든 객체들이 메모리를 할당받게 됩니다.

![minor-gc-2](/assets/img/language/java/gc/minor-gc-2.png)

![minor-gc-3](/assets/img/language/java/gc/minor-gc-3.png)

그 후 Eden 영역이 가득차게 되면 Minor GC가 발생하여 참조가 없는 객체들은 메모리가 해제되며 참조 중인 객체는 Survivor Spaces 중 Survivor 0(S0, From Area) 영억으로 이동합니다.

![minor-gc-4](/assets/img/language/java/gc/minor-gc-4.png)

또 다시 Eden 영역이 가득 차게 되면 Minor GC가 발생합니다.  

![minor-gc-5](/assets/img/language/java/gc/minor-gc-5.png)  

그리고 살아남은 모든 객체들의 Age 값을 1씩 증가시킵니다. 

![minor-gc-6](/assets/img/language/java/gc/minor-gc-6.png)

또 다시 Eden 영역이 가득 차게 되면 Minor GC가 발생합니다.

![minor-gc-7](/assets/img/language/java/gc/minor-gc-7.png)

살아남은 모든 객체들을 Survivor 1(S1, To Area)로 이동시킵니다.  

![minor-gc-8](/assets/img/language/java/gc/minor-gc-8.png)

그 후 Minor GC 주기 동안 살아남은 객체의 Age를 1씩 증가시킵니다. 

![minor-gc-9](/assets/img/language/java/gc/minor-gc-9.png)

이런 식으로 Minor GC는 Minor GC 주기마다 살아남은 객체들의 Age를  증가시키며 S0, S1 영역을 번갈아가며 객체들을 저장합니다.  




# 알고리즘

# 성능과 튜닝


오탈자 및 오류 내용을 댓글 또는 메일로 알려주시면, 검토 후 조치하겠습니다.
