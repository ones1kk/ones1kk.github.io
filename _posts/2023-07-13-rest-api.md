---
title: REST API
date: 2023-07-13 00:00:00 +09:00
categories: [ Software Architecture, Architecture Style ]
tags: [ REST-API, API, RESTful ]
---

# REST API

![rest-api](/assets/img/web/Term/rest-api/rest-api.png)

> [출처](https://blog.postman.com/rest-api-examples/)

REST(REST: Representational State Transfer)는 리소스의 표현으로 구분하여 해당 리소스의 상태를 주고 받는 개념으로 웹 서비스의 자원을 고유한 URI(Uniform Resource
Identifier)로 표현하고, HTTP 프로토콜을 통해 클라이언트와 상호 작용하는 아키텍처 스타일입니다.  
REST는 2000년 로이 필딩(Roy Fielding)이 정의한 아키텍처 스타일(architectural style)로 아키텍처 스타일이란 **아키텍처에 적용되는 제약조건들의 집합**입니다.
로이필딩은 REST를 **Starting With the Null Style** 방식을 이용하여 아키텍처를 설계하였으며 이는 어떤 제약 조건 없이 시스템의 전반에서 시작하여 점진적으로 제약 조건을 추가하는 방식입니다.
추가한 제약 조건들은 시스템내에서 조화롭고 자연스럽게 동작할 수 있도록 설계되며 이는 시스템 맥락에 대한 이해와 규제를 강조합니다.  

REST의 특징을 도출해내기 위해서 설계 과정에서 추가된 제약 조건은 어떤 것이 있는지 알아 보도록 하겠습니다.

## 제약 조건

### Client-Server

![client_server_style](/assets/img/software-architecture/architecture-style/client_server_style.png)

클라이언트-서버 제약 조건은 관심사의 분리(Seperation of Concern)에 대한 내용입니다.
데이터의 저장에 대한 관심사와 사용자 인터페이스에 대한 관심사를 분리함으로써 서버와 클라이언트는 독립적으로 수행될 수 있습니다.
즉 클라이언트 측의 코드는 서버의 동작에 영향을 주지 않고 언제든지 변경할 수 있고 서버 측의 코드는 클라이언트의 동작에 영향을 주지 않고 변경할 수 있음을 의미합니다.
이는 서버와 클라이언트의 역할에 맞게 독립적으로 각각 발전시킬 수 있습니다.

### Stateless

![stateless_cs](/assets/img/software-architecture/architecture-style/stateless_cs.png)

Stateless 제약 조건은 클라이언트와 서버 사이의 상호 작용입니다.
클라이언트가 서버에 보내는 요청은 상태를 관리하지 않고 모든 요청은 독립적으로 처리됩니다.
클라이언트의 상태 정보는 서버에 저장되지 않으며 필요한 정보는 요청 자체에 포함되어야 합니다.

stateless 통신을 이용함으로써 다음과 같은 이점을 가질 수 있습니다.

- 가시성(Visibility): 서버는 클라이언트가 보낸 요청의 전체 특성을 파악하기 위해서는 해당 요청 외에는 다른 것을 고려하지 않아도 되기 때문에 가시성이 향상됩니다.
- 신뢰성(Reliability): 서버는 장애를 복구하기 위해서 클라이언트의 단일 요청만 고려하기 때문에 복구가 용이하고 서버의 장애 발생 시 다른 서버로 요청을 전달하여 부하 분산이 가능하며 이러한 확장성을 통해
  신뢰성을 높일 수 있습니다.
- 확장성(Scalability): 요청 간에 상태를 저장할 필요가 없기 때문에 서버 구성 요소가 리소스를 신속하게 해제할 수 있고 서버가 요청 간에 리소스 사용을 관리할 필요가 없기 때문에
  구현이 더욱 간소화되어 확장성이 향상됩니다.

Stateless 통신은 위와 같은 장점을 가지고 있지만 Stateful 통신과 대비되는 단점 또한 존재합니다.
클라이언트의 요청 정보가 서버에 저장되지 않기 때문에 매번 요청을 보낼 때마다 클라이언트의 부가 정보 추가로 전송해야하는 부분은 네트워크 성능을 저하시키는 요인 중 하나입니다.

### Cache

![ccss_style](/assets/img/software-architecture/architecture-style/ccss_style.png)

캐시 제약 조건은 네트워크 성능을 향상 시키기 위함입니다.
HTTP(Hyper Text Transfer Protocol)라는 기존 웹 표준을 사용하는 REST의 특징 덕분에 기본 웹에서 사용되는 인프라를 모두 사용이 가능합니다.
요청에 대한 응답 데이터가 암시적 또는 명시적으로 cacheable한지 non-cacheable한지 지정되어야 하는데 REST는 웹 기본 인프라를 이용해 응답 데이터의 캐시 가능 여부를 처리합니다.

캐시 제약 조건을 통해 지속적인 상호 작용(서버와 클라이언트 간의 통신)을 부분적으로 또는 완전히 제거하여 평균 통신 시간을 줄일 수 있다는 점입니다.  
반면 서버가 가지고 있는 데이터와 클라이언트가 가지고 있는 캐시 데이터에 다르거나 오래된 데이터가 포함되어 있다면 요청-응답에 대한 신뢰성이 저하될 수 있다는 단점이 있습니다.

### Uniform Interface

![uniform_ccss](/assets/img/software-architecture/architecture-style/uniform_ccss.png)

REST 아키텍처 스타일을 다른 네트워크 기반 스타일과 구별하는 주요한 특징으로 구성요소 간의 균일한 인터페이스에 중점을 둔다는 것입니다.
소프트웨어 공학의 원칙인 일반성(Generality)을 적용함으로써, 전체 아키텍처는 단순화되고 상호 작용의 가시성이 향상됩니다.
모든 컴포넌트들은 서비스로 부터 분리되어 각 컴포넌트 별로 독립적으로 발전할 수 있는 진화 가능성(Evolvability)를 가지게 됩니다.

Uniform Interface를 가지기 위해서는 다음과 같은 제약 조건을 따릅니다.

- Identification of Resources (리소스 식별): 
- Manipulation of Resources through Representations (표현을 통한 리소스 조작): 
- Self-descriptive Messages (자체 기술적인 메시지):
- Hypermedia as the Engine of Application State (하이퍼미디어를 응용프로그램 상태의 엔진으로 활용): 

### Layerd System

![layered_uccss](/assets/img/software-architecture/architecture-style/layered_uccss.png)

### Code-on-Demand

![rest_style](/assets/img/software-architecture/architecture-style/rest_style.png)

### Style Derivation Summary

![rest_derivation](/assets/img/software-architecture/architecture-style/rest_derivation.png)

# RESTful API 

로이 필딩의 [Architectural Styles and the Design of Network-based Software Architectures](https://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm)
를 참고하여 작성했습니다.

오탈자 및 오류 내용을 댓글 또는 메일로 알려주시면, 검토 후 조치하겠습니다.  
